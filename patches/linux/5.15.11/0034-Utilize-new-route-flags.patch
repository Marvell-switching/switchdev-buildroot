From 6699dbc3cf4eff655ab1cc69af7ecbd7907d05d6 Mon Sep 17 00:00:00 2001
From: Yevhen Orlov <yevhen.orlov@plvision.eu>
Date: Fri, 21 Jan 2022 04:58:42 +0200
Subject: [PATCH 34/40] Utilize new route flags

* Store tos and type fields in fib cache,
  as they used in new kernel interface
* Remove "allow_oflag" as it will not be used in the future
* Add function to utilize fib_alias_hw_flags_set
* Update fib flags in fc_apply
* Refactor fc_apply, as it became too long
* Remove unused static function

JIRA: SWITCHDEV-2534
Signed-off-by: Yevhen Orlov <yevhen.orlov@plvision.eu>
Change-Id: Icfda73c6eb4b8555555fbf1cc19fb83294874602
---
 .../marvell/prestera/prestera_router.c        | 135 +++++++++++-------
 1 file changed, 84 insertions(+), 51 deletions(-)

diff --git a/drivers/net/ethernet/marvell/prestera/prestera_router.c b/drivers/net/ethernet/marvell/prestera/prestera_router.c
index 006433f0d311..c5516b135a2e 100644
--- a/drivers/net/ethernet/marvell/prestera/prestera_router.c
+++ b/drivers/net/ethernet/marvell/prestera/prestera_router.c
@@ -89,7 +89,6 @@ struct mvsw_pr_kern_fib_cache {
 	} lpm_info; /* hold prepared lpm info */
 	/* Indicate if route is not overlapped by another table */
 	bool reachable;
-	bool allow_oflag;
 	struct rhash_head ht_node; /* node of mvsw_pr_router */
 	struct mvsw_pr_kern_neigh_cache_head {
 		struct mvsw_pr_kern_fib_cache *this;
@@ -97,6 +96,8 @@ struct mvsw_pr_kern_fib_cache {
 		struct prestera_kern_neigh_cache *n_cache;
 	} kern_neigh_cache_head[PRESTERA_NHGR_SIZE_MAX];
 	struct fib_info *fi;
+	u8 kern_tos;
+	u8 kern_type;
 };
 
 static const struct rhashtable_params __mvsw_pr_kern_neigh_cache_ht_params = {
@@ -179,8 +180,6 @@ static int mvsw_pr_rif_update(struct prestera_switch *sw,
 static struct prestera_rif *mvsw_pr_rif_find(const struct prestera_switch *sw,
 					     const struct net_device *dev);
 static bool mvsw_pr_fi_is_direct(struct fib_info *fi);
-static bool mvsw_pr_fi_is_hw_direct(struct prestera_switch *sw,
-				    struct fib_info *fi);
 static bool mvsw_pr_fi_is_nh(struct fib_info *fi);
 static bool
 mvsw_pr_fib_node_util_is_neighbour(struct prestera_fib_node *fib_node);
@@ -695,7 +694,7 @@ mvsw_pr_kern_fib_cache_destroy(struct prestera_switch *sw,
 static struct mvsw_pr_kern_fib_cache *
 prestera_kern_fib_cache_create(struct prestera_switch *sw,
 			       struct mvsw_pr_kern_fib_cache_key *key,
-			       struct fib_info *fi)
+			       struct fib_info *fi, u8 tos, u8 type)
 {
 	struct mvsw_pr_kern_fib_cache *fib_cache;
 	struct prestera_kern_neigh_cache *n_cache;
@@ -709,10 +708,8 @@ prestera_kern_fib_cache_create(struct prestera_switch *sw,
 	memcpy(&fib_cache->key, key, sizeof(*key));
 	fib_info_hold(fi);
 	fib_cache->fi = fi;
-	/* This is for unnatural offload flag logic
-	 * to satisfy user expectations.
-	 */
-	fib_cache->allow_oflag |= !!mvsw_pr_fi_is_hw_direct(sw, fi);
+	fib_cache->kern_tos = tos;
+	fib_cache->kern_type = type;
 
 	err = rhashtable_insert_fast(&sw->router->kern_fib_cache_ht,
 				     &fib_cache->ht_node,
@@ -745,11 +742,6 @@ prestera_kern_fib_cache_create(struct prestera_switch *sw,
 			 &n_cache->kern_fib_cache_list);
 	}
 
-	/* This is for unnatural offload flag logic
-	 * to satisfy user expectations.
-	 */
-	fib_cache->allow_oflag |= !!nhs;
-
 out:
 	return fib_cache;
 
@@ -761,10 +753,10 @@ prestera_kern_fib_cache_create(struct prestera_switch *sw,
 }
 
 static void
-__mvsw_pr_k_arb_fib_offload_set(struct prestera_switch *sw,
-				struct mvsw_pr_kern_fib_cache *fibc,
-				struct prestera_kern_neigh_cache *nc,
-				bool offloaded)
+__prestera_k_arb_fib_nh_offload_set(struct prestera_switch *sw,
+				    struct mvsw_pr_kern_fib_cache *fibc,
+				    struct prestera_kern_neigh_cache *nc,
+				    bool offloaded)
 {
 	int i, nhs;
 	struct fib_nh *fib_nh;
@@ -784,6 +776,30 @@ __mvsw_pr_k_arb_fib_offload_set(struct prestera_switch *sw,
 	}
 }
 
+static void
+__prestera_k_arb_fib_lpm_offload_set(struct prestera_switch *sw,
+				     struct mvsw_pr_kern_fib_cache *fc,
+				     bool fail, bool offload, bool trap)
+{
+	struct fib_rt_info fri;
+
+	if (fc->key.addr.v != PRESTERA_IPV4)
+		return;
+
+	fri.fi = fc->fi;
+	fri.tb_id = fc->key.kern_tb_id;
+	fri.dst = fc->key.addr.u.ipv4;
+	fri.dst_len = fc->key.prefix_len;
+	fri.tos = fc->kern_tos;
+	fri.type = fc->kern_type;
+	/* flags begin */
+	fri.offload = offload;
+	fri.trap = trap;
+	fri.offload_failed = fail;
+	/* flags end */
+	fib_alias_hw_flags_set(&init_net, &fri);
+}
+
 static void
 __mvsw_pr_k_arb_n_offload_set(struct prestera_switch *sw,
 			      struct prestera_kern_neigh_cache *nc,
@@ -967,10 +983,9 @@ __mvsw_pr_k_arb_nc_apply(struct prestera_switch *sw,
 
 out:
 	list_for_each_entry(nhead, &nc->kern_fib_cache_list, head) {
-		__mvsw_pr_k_arb_fib_offload_set(sw, nhead->this, nc,
-						nc->in_kernel &&
-						nhead->this->reachable &&
-						nhead->this->allow_oflag);
+		__prestera_k_arb_fib_nh_offload_set(sw, nhead->this, nc,
+						    nc->in_kernel &&
+						    nhead->this->reachable);
 	}
 }
 
@@ -1047,10 +1062,10 @@ static int __mvsw_pr_k_arb_f_lpm_set(struct prestera_switch *sw,
 	return 0;
 }
 
-static int __mvsw_pr_k_arb_fc_apply(struct prestera_switch *sw,
-				    struct mvsw_pr_kern_fib_cache *fc)
+static int
+__prestera_pr_k_arb_fc_lpm_info_calc(struct prestera_switch *sw,
+				     struct mvsw_pr_kern_fib_cache *fc)
 {
-	int err;
 	int nh_cnt;
 	struct prestera_rif *rif;
 	struct fib_nh *fib_nh;
@@ -1113,16 +1128,46 @@ static int __mvsw_pr_k_arb_fc_apply(struct prestera_switch *sw,
 
 	mvsw_pr_util_fib_cache_key2fib_key(&fc->key,
 					   &fc->lpm_info.fib_key);
+	return 0;
+}
 
-	/* 1. Update lpm */
-	err = __mvsw_pr_k_arb_f_lpm_set(sw, fc, fc->reachable);
+static int __mvsw_pr_k_arb_fc_apply(struct prestera_switch *sw,
+				    struct mvsw_pr_kern_fib_cache *fc)
+{
+	int err;
+
+	err = __prestera_pr_k_arb_fc_lpm_info_calc(sw, fc);
 	if (err)
 		return err;
 
-	/* UC_NH offload flag is managed by neighbours cache */
-	if (fc->lpm_info.fib_type != PRESTERA_FIB_TYPE_UC_NH || !fc->reachable)
-		__mvsw_pr_k_arb_fib_offload_set(sw, fc, NULL, fc->reachable &&
-						fc->allow_oflag);
+	err = __mvsw_pr_k_arb_f_lpm_set(sw, fc, fc->reachable);
+	if (err) {
+		__prestera_k_arb_fib_lpm_offload_set(sw, fc,
+						     true, false, false);
+		__prestera_k_arb_fib_nh_offload_set(sw, fc, NULL,
+						    false);
+		return err;
+	}
+
+	switch (fc->lpm_info.fib_type) {
+	case PRESTERA_FIB_TYPE_UC_NH:
+		/* let nc_apply manage nexthops */
+		__prestera_k_arb_fib_lpm_offload_set(sw, fc, false,
+						     fc->reachable, false);
+		break;
+	case PRESTERA_FIB_TYPE_TRAP:
+		__prestera_k_arb_fib_nh_offload_set(sw, fc, NULL, false);
+		__prestera_k_arb_fib_lpm_offload_set(sw, fc, false,
+						     false, fc->reachable);
+		break;
+	case PRESTERA_FIB_TYPE_DROP:
+		__prestera_k_arb_fib_nh_offload_set(sw, fc, NULL, false);
+		__prestera_k_arb_fib_lpm_offload_set(sw, fc, false, true,
+						     false);
+		break;
+	case PRESTERA_FIB_TYPE_INVALID:
+		break;
+	}
 
 	return 0;
 }
@@ -1215,8 +1260,8 @@ static void __mvsw_pr_k_arb_abort_fib(struct prestera_switch *sw)
 		} else if (IS_ERR(fib_cache)) {
 			continue;
 		} else if (fib_cache) {
-			__mvsw_pr_k_arb_fib_offload_set(sw, fib_cache, NULL,
-							false);
+			__prestera_k_arb_fib_nh_offload_set(sw, fib_cache, NULL,
+							    false);
 			/* No need to destroy lpm.
 			 * It will be aborted by destroy_ht
 			 */
@@ -1397,7 +1442,9 @@ mvsw_pr_k_arb_fib_evt(struct prestera_switch *sw,
 
 	if (replace) {
 		fib_cache = prestera_kern_fib_cache_create(sw, &fc_key,
-							   fen_info->fi);
+							   fen_info->fi,
+							   fen_info->tos,
+							   fen_info->type);
 		if (!fib_cache) {
 			MVSW_LOG_ERROR("fib_cache == NULL");
 			return -ENOENT;
@@ -1460,17 +1507,20 @@ __mvsw_pr_k_arb_fc_rebuild(struct prestera_switch *sw,
 	struct mvsw_pr_kern_fib_cache_key key;
 	struct mvsw_pr_kern_fib_cache *new_fc;
 	bool reachable;
+	u8 tos, type;
 
 	memcpy(&key, &fc->key, sizeof(key));
 	fi = fc->fi;
 	fib_info_hold(fi);
 	reachable = fc->reachable;
+	tos = fc->kern_tos;
+	type = fc->kern_type;
 
 	fc->reachable = false;
 	__mvsw_pr_k_arb_fc_apply(sw, fc);
 	mvsw_pr_kern_fib_cache_destroy(sw, fc);
 
-	new_fc = prestera_kern_fib_cache_create(sw, &key, fi);
+	new_fc = prestera_kern_fib_cache_create(sw, &key, fi, tos, type);
 	fib_info_put(fi);
 	if (!new_fc)
 		return NULL;
@@ -2105,23 +2155,6 @@ static bool mvsw_pr_fi_is_direct(struct fib_info *fi)
 	return __mvsw_pr_fi_is_direct(fi);
 }
 
-static bool mvsw_pr_fi_is_hw_direct(struct prestera_switch *sw,
-				    struct fib_info *fi)
-{
-	struct fib_nh *fib_nh;
-	struct prestera_rif *rif;
-
-	if (!mvsw_pr_fi_is_direct(fi))
-		return false;
-
-	fib_nh = fib_info_nh(fi, 0);
-	rif = mvsw_pr_rif_find(sw, fib_nh->fib_nh_dev);
-	if (!rif || !rif->is_active)
-		return false;
-
-	return true;
-}
-
 static bool mvsw_pr_fi_is_nh(struct fib_info *fi)
 {
 	if (fi->fib_type != RTN_UNICAST)
-- 
2.17.1

