From 61255393410428ee41c8d6d3cfb381d67a8ae79b Mon Sep 17 00:00:00 2001
From: Yevhen Orlov <yevhen.orlov@plvision.eu>
Date: Wed, 19 Jan 2022 20:58:26 +0200
Subject: [PATCH 31/40] Remove abort field and related logic

Abort mechanism is not used anymore in upstream.

There is a lot of pending mechanisms in kernel to notify user about
offloading problems (flags, returns, etc.). So there is no sense to fail
whole driver on one error.

JIRA: SWITCHDEV-2533
Signed-off-by: Yevhen Orlov <yevhen.orlov@plvision.eu>
Change-Id: I86a9206f63f7ccfee2992517636744ab2804fcfc
---
 .../net/ethernet/marvell/prestera/prestera.h  |  1 -
 .../ethernet/marvell/prestera/prestera_main.c | 42 -------------------
 .../marvell/prestera/prestera_router.c        | 22 +---------
 3 files changed, 2 insertions(+), 63 deletions(-)

diff --git a/drivers/net/ethernet/marvell/prestera/prestera.h b/drivers/net/ethernet/marvell/prestera/prestera.h
index 9669c43d1d7c..b9787d382db5 100644
--- a/drivers/net/ethernet/marvell/prestera/prestera.h
+++ b/drivers/net/ethernet/marvell/prestera/prestera.h
@@ -415,7 +415,6 @@ struct prestera_router {
 	struct notifier_block netevent_nb;
 	struct notifier_block inetaddr_nb;
 	struct notifier_block fib_nb;
-	bool aborted;
 };
 
 enum prestera_fdb_flush_mode {
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_main.c b/drivers/net/ethernet/marvell/prestera/prestera_main.c
index aa4ce2b90abb..36cae9ce4c18 100644
--- a/drivers/net/ethernet/marvell/prestera/prestera_main.c
+++ b/drivers/net/ethernet/marvell/prestera/prestera_main.c
@@ -1217,12 +1217,6 @@ int prestera_dev_if_type(const struct net_device *dev)
 int prestera_lpm_add(struct prestera_switch *sw, u16 hw_vr_id,
 		     struct prestera_ip_addr *addr, u32 prefix_len, u32 grp_id)
 {
-	/* Dont waste time on hw requests,
-	 * if router (and probably vr) aborted
-	 */
-	if (sw->router->aborted)
-		return -ENOENT;
-
 	/* TODO: ipv6 key type check before call designated hw cb */
 	return prestera_hw_lpm_add(sw, hw_vr_id, addr->u.ipv4,
 				   prefix_len, grp_id);
@@ -1231,12 +1225,6 @@ int prestera_lpm_add(struct prestera_switch *sw, u16 hw_vr_id,
 int prestera_lpm_del(struct prestera_switch *sw, u16 hw_vr_id,
 		     struct prestera_ip_addr *addr, u32 prefix_len)
 {
-	/* Dont waste time on hw requests,
-	 * if router (and probably vr) aborted
-	 */
-	if (sw->router->aborted)
-		return -ENOENT;
-
 	/* TODO: ipv6 key type check before call designated hw cb */
 	return prestera_hw_lpm_del(sw, hw_vr_id, addr->u.ipv4,
 				   prefix_len);
@@ -1245,60 +1233,30 @@ int prestera_lpm_del(struct prestera_switch *sw, u16 hw_vr_id,
 int prestera_nh_entries_set(const struct prestera_switch *sw, int count,
 			    struct prestera_neigh_info *nhs, u32 grp_id)
 {
-	/* Dont waste time on hw requests,
-	 * if router (and probably vr) aborted
-	 */
-	if (sw->router->aborted)
-		return -ENOENT;
-
 	return prestera_hw_nh_entries_set(sw, count, nhs, grp_id);
 }
 
 int prestera_nh_entries_get(const struct prestera_switch *sw, int count,
 			    struct prestera_neigh_info *nhs, u32 grp_id)
 {
-	/* Dont waste time on hw requests,
-	 * if router (and probably vr) aborted
-	 */
-	if (sw->router->aborted)
-		return -ENOENT;
-
 	return prestera_hw_nh_entries_get(sw, count, nhs, grp_id);
 }
 
 int prestera_nhgrp_blk_get(const struct prestera_switch *sw, u8 *hw_state,
 			   u32 buf_size)
 {
-	/* Dont waste time on hw requests,
-	 * if router (and probably vr) aborted
-	 */
-	if (sw->router->aborted)
-		return -ENOENT;
-
 	return prestera_hw_nhgrp_blk_get(sw, hw_state, buf_size);
 }
 
 int prestera_nh_group_create(const struct prestera_switch *sw, u16 nh_count,
 			     u32 *grp_id)
 {
-	/* Dont waste time on hw requests,
-	 * if router (and probably vr) aborted
-	 */
-	if (sw->router->aborted)
-		return -ENOENT;
-
 	return prestera_hw_nh_group_create(sw, nh_count, grp_id);
 }
 
 int prestera_nh_group_delete(const struct prestera_switch *sw, u16 nh_count,
 			     u32 grp_id)
 {
-	/* Dont waste time on hw requests,
-	 * if router (and probably vr) aborted
-	 */
-	if (sw->router->aborted)
-		return -ENOENT;
-
 	return prestera_hw_nh_group_delete(sw, nh_count, grp_id);
 }
 
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_router.c b/drivers/net/ethernet/marvell/prestera/prestera_router.c
index 32d0b120f3bb..621dfccf14ca 100644
--- a/drivers/net/ethernet/marvell/prestera/prestera_router.c
+++ b/drivers/net/ethernet/marvell/prestera/prestera_router.c
@@ -1549,12 +1549,8 @@ static void mvsw_pr_router_neigh_event_work(struct work_struct *work)
 	/* neigh - its not hw related object. It stored only in kernel. So... */
 	mvsw_owq_lock();
 
-	if (sw->router->aborted)
-		goto out;
-
 	mvsw_pr_k_arb_n_evt(sw, n);
 
-out:
 	neigh_release(n);
 	mvsw_owq_unlock();
 	kfree(net_work);
@@ -1607,12 +1603,8 @@ static void mvsw_pr_router_update_neighs_work(struct work_struct *work)
 			      neighs_update.dw.work);
 	rtnl_lock();
 
-	if (router->aborted)
-		goto out;
-
 	mvsw_pr_k_arb_hw_evt(router->sw);
 
-out:
 	rtnl_unlock();
 	mvsw_pr_router_neighs_update_interval_init(router);
 	queue_delayed_work(mvsw_r_wq, &router->neighs_update.dw,
@@ -2173,14 +2165,11 @@ static void mvsw_pr_router_fib4_event_work(struct work_struct *work)
 
 	mvsw_owq_lock();
 
-	if (sw->router->aborted)
-		goto out;
-
 	switch (fib_work->event) {
 	case FIB_EVENT_ENTRY_REPLACE:
 		err = mvsw_pr_k_arb_fib_evt(sw, true, &fib_work->fen_info);
 		if (err)
-			goto abort_out;
+			goto err_out;
 
 		break;
 	case FIB_EVENT_ENTRY_DEL:
@@ -2195,13 +2184,10 @@ static void mvsw_pr_router_fib4_event_work(struct work_struct *work)
 
 	goto out;
 
-abort_out:
+err_out:
 	dev_err(sw->dev->dev, "Error when processing %pI4h/%d",
 		&fib_work->fen_info.dst,
 		fib_work->fen_info.dst_len);
-	sw->router->aborted = true;
-	mvsw_pr_router_fib_abort(sw);
-	dev_err(sw->dev->dev, "Abort. HW routing offloading disabled");
 out:
 	fib_info_put(fib_work->fen_info.fi);
 	mvsw_owq_unlock();
@@ -2217,14 +2203,10 @@ static void mvsw_pr_router_nh_update_event_work(struct work_struct *work)
 
 	mvsw_owq_lock();
 
-	if (sw->router->aborted)
-		goto out;
-
 	/* For now provided only deletion */
 	if (fib_work->event == FIB_EVENT_NH_DEL)
 		mvsw_pr_k_arb_nh_evt(sw, false, fib_nh);
 
-out:
 	fib_info_put(fib_nh->nh_parent);
 	mvsw_owq_unlock();
 	kfree(fib_work);
-- 
2.17.1

