From 8c8329c2d4b711a236a02d7ffdf1ed04074c0ed1 Mon Sep 17 00:00:00 2001
From: Yevhen Orlov <yevhen.orlov@plvision.eu>
Date: Wed, 26 Jan 2022 23:25:08 +0200
Subject: [PATCH 37/40] Utilize RTNH_F_TRAP

We can untie nh flags from route. NH can be marked as offload/trap
separately from route.

JIRA: SWITCHDEV-2534
Signed-off-by: Yevhen Orlov <yevhen.orlov@plvision.eu>
Change-Id: Icfda73c6eb4b8ababababf1cc19fb83294874602
---
 .../marvell/prestera/prestera_router.c        | 29 ++++++++++++-------
 1 file changed, 18 insertions(+), 11 deletions(-)

diff --git a/drivers/net/ethernet/marvell/prestera/prestera_router.c b/drivers/net/ethernet/marvell/prestera/prestera_router.c
index b4923ba72b29..3a38c02028e6 100644
--- a/drivers/net/ethernet/marvell/prestera/prestera_router.c
+++ b/drivers/net/ethernet/marvell/prestera/prestera_router.c
@@ -328,12 +328,18 @@ static void mvsw_pr_util_kern_set_neigh_offload(struct neighbour *n,
 }
 
 static void
-mvsw_pr_util_kern_set_nh_offload(struct fib_nh *fib_nh, bool offloaded)
+prestera_util_kern_set_nh_offload(struct fib_nh *fib_nh, bool offloaded,
+				  bool trap)
 {
 		if (offloaded)
 			fib_nh->fib_nh_flags |= RTNH_F_OFFLOAD;
 		else
 			fib_nh->fib_nh_flags &= ~RTNH_F_OFFLOAD;
+
+		if (trap)
+			fib_nh->fib_nh_flags |= RTNH_F_TRAP;
+		else
+			fib_nh->fib_nh_flags &= ~RTNH_F_TRAP;
 }
 
 /* must be called with rcu_read_lock() */
@@ -756,7 +762,7 @@ static void
 __prestera_k_arb_fib_nh_offload_set(struct prestera_switch *sw,
 				    struct mvsw_pr_kern_fib_cache *fibc,
 				    struct prestera_kern_neigh_cache *nc,
-				    bool offloaded)
+				    bool offloaded, bool trap)
 {
 	int i, nhs;
 	struct fib_nh *fib_nh;
@@ -765,12 +771,14 @@ __prestera_k_arb_fib_nh_offload_set(struct prestera_switch *sw,
 	for (i = 0; i < nhs; i++) {
 		fib_nh = fib_info_nh(fibc->fi, i);
 		if (!nc) {
-			mvsw_pr_util_kern_set_nh_offload(fib_nh, offloaded);
+			prestera_util_kern_set_nh_offload(fib_nh, offloaded,
+							  trap);
 			continue;
 		}
 
 		if (prestera_util_fib_nh_eq_n_cache_key(sw, fib_nh, &nc->key)) {
-			mvsw_pr_util_kern_set_nh_offload(fib_nh, offloaded);
+			prestera_util_kern_set_nh_offload(fib_nh, offloaded,
+							  trap);
 			break;
 		}
 	}
@@ -984,8 +992,8 @@ __mvsw_pr_k_arb_nc_apply(struct prestera_switch *sw,
 out:
 	list_for_each_entry(nhead, &nc->kern_fib_cache_list, head) {
 		__prestera_k_arb_fib_nh_offload_set(sw, nhead->this, nc,
-						    nc->in_kernel &&
-						    nhead->this->reachable);
+						    nc->in_kernel,
+						    !nc->in_kernel);
 	}
 }
 
@@ -1144,8 +1152,6 @@ static int __mvsw_pr_k_arb_fc_apply(struct prestera_switch *sw,
 	if (err) {
 		__prestera_k_arb_fib_lpm_offload_set(sw, fc,
 						     true, false, false);
-		__prestera_k_arb_fib_nh_offload_set(sw, fc, NULL,
-						    false);
 		return err;
 	}
 
@@ -1156,12 +1162,10 @@ static int __mvsw_pr_k_arb_fc_apply(struct prestera_switch *sw,
 						     fc->reachable, false);
 		break;
 	case PRESTERA_FIB_TYPE_TRAP:
-		__prestera_k_arb_fib_nh_offload_set(sw, fc, NULL, false);
 		__prestera_k_arb_fib_lpm_offload_set(sw, fc, false,
 						     false, fc->reachable);
 		break;
 	case PRESTERA_FIB_TYPE_DROP:
-		__prestera_k_arb_fib_nh_offload_set(sw, fc, NULL, false);
 		__prestera_k_arb_fib_lpm_offload_set(sw, fc, false, true,
 						     false);
 		break;
@@ -1260,8 +1264,11 @@ static void __mvsw_pr_k_arb_abort_fib(struct prestera_switch *sw)
 		} else if (IS_ERR(fib_cache)) {
 			continue;
 		} else if (fib_cache) {
+			__prestera_k_arb_fib_lpm_offload_set(sw, fib_cache,
+							     true, false,
+							     false);
 			__prestera_k_arb_fib_nh_offload_set(sw, fib_cache, NULL,
-							    false);
+							    false, false);
 			/* No need to destroy lpm.
 			 * It will be aborted by destroy_ht
 			 */
-- 
2.17.1

