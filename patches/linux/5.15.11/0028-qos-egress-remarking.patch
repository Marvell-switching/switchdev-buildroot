From 9b303afbebe169119f414ba6f911b8c1db0ac270 Mon Sep 17 00:00:00 2001
From: Serhiy Boiko <serhiy.boiko@plvision.eu>
Date: Mon, 1 Nov 2021 11:35:09 +0200
Subject: [PATCH 28/40] qos: egress remarking

 Add support for qos egress remarking using ACL rules.

 JIRA: SWITCHDEV-2522

 Signed-off-by: Serhiy Boiko <serhiy.boiko@plvision.eu>
 Change-Id: I7e871ee65ff94c277d84ee110c139315219bbb5f
 ---
  .../prestera_sw/prestera.h                    |  13 +-
  .../prestera_sw/prestera_acl.c                |   9 +
  .../prestera_sw/prestera_acl.h                |   8 +
  .../prestera_sw/prestera_dcb.c                | 235 ++++++++++++++++--
  .../prestera_sw/prestera_hw.c                 |  10 +-
---
 .../net/ethernet/marvell/prestera/prestera.h  |  13 +-
 .../ethernet/marvell/prestera/prestera_acl.c  |   9 +
 .../ethernet/marvell/prestera/prestera_acl.h  |   8 +
 .../ethernet/marvell/prestera/prestera_dcb.c  | 235 ++++++++++++++++--
 .../ethernet/marvell/prestera/prestera_hw.c   |  10 +-
 5 files changed, 249 insertions(+), 26 deletions(-)

diff --git a/drivers/net/ethernet/marvell/prestera/prestera.h b/drivers/net/ethernet/marvell/prestera/prestera.h
index 8d74db5e3d34..9669c43d1d7c 100644
--- a/drivers/net/ethernet/marvell/prestera/prestera.h
+++ b/drivers/net/ethernet/marvell/prestera/prestera.h
@@ -30,6 +30,7 @@
 #define PRESTERA_PORT_SRCID_ZERO 0 /* source_id */
 
 #define PRESTERA_SPAN_INVALID_ID -1
+#define PRESTERA_QOS_SP_COUNT 8
 
 struct prestera_fw_rev {
 	u16 maj;
@@ -46,6 +47,7 @@ struct prestera_acl_nat_port;
 struct prestera_span;
 struct prestera_span_entry;
 struct prestera_storm_control;
+struct prestera_qos;
 
 struct prestera_flow_block_binding {
 	struct list_head list;
@@ -192,7 +194,6 @@ struct prestera_port {
 	u64 adver_link_modes;
 	u8 adver_fec;
 	u16 lag_id;
-	u32 qos_trust_mode;
 	struct prestera_port_caps caps;
 	struct prestera_port_mac_config cfg_mac;
 	struct prestera_port_phy_config cfg_phy;
@@ -203,6 +204,7 @@ struct prestera_port {
 		struct delayed_work caching_dw;
 	} cached_hw_stats;
 	struct prestera_flow_block *flow_block;
+	struct prestera_qos *qos;
 
 	struct phylink_config phy_config;
 	struct phylink *phy_link;
@@ -461,6 +463,7 @@ enum prestera_acl_match_type {
 	PRESTERA_ACL_RULE_MATCH_TYPE_VLAN_TPID,
 	PRESTERA_ACL_RULE_MATCH_TYPE_ICMP_TYPE,
 	PRESTERA_ACL_RULE_MATCH_TYPE_ICMP_CODE,
+	PRESTERA_ACL_RULE_MATCH_TYPE_QOS_PROFILE,
 
 	__PRESTERA_ACL_RULE_MATCH_TYPE_MAX
 };
@@ -478,7 +481,8 @@ enum prestera_acl_rule_action {
 	PRESTERA_ACL_RULE_ACTION_NAT,
 	PRESTERA_ACL_RULE_ACTION_JUMP,
 	PRESTERA_ACL_RULE_ACTION_NH,
-	PRESTERA_ACL_RULE_ACTION_COUNT
+	PRESTERA_ACL_RULE_ACTION_COUNT,
+	PRESTERA_ACL_RULE_ACTION_REMARK
 };
 
 struct prestera_acl_action_jump {
@@ -506,6 +510,10 @@ struct prestera_acl_action_count {
 	u32 id;
 };
 
+struct prestera_acl_action_remark {
+	u32 dscp;
+};
+
 /* Used for hw call */
 struct prestera_acl_hw_action_info {
 	enum prestera_acl_rule_action id;
@@ -516,6 +524,7 @@ struct prestera_acl_hw_action_info {
 		struct prestera_acl_action_nat nat;
 		struct prestera_acl_action_jump jump;
 		struct prestera_acl_action_count count;
+		struct prestera_acl_action_remark remark;
 	};
 };
 
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_acl.c b/drivers/net/ethernet/marvell/prestera/prestera_acl.c
index a0f4a03ecbf3..b76fa1b7c6f3 100644
--- a/drivers/net/ethernet/marvell/prestera/prestera_acl.c
+++ b/drivers/net/ethernet/marvell/prestera/prestera_acl.c
@@ -917,6 +917,12 @@ static int __prestera_acl_rule_entry2hw_add(struct prestera_switch *sw,
 		act_hw[act_num].count.id = e->counter.id;
 		act_num++;
 	}
+	/* egress remark */
+	if (e->remark.valid) {
+		act_hw[act_num].id = PRESTERA_ACL_RULE_ACTION_REMARK;
+		act_hw[act_num].remark = e->remark.i;
+		act_num++;
+	}
 
 	return prestera_hw_vtcam_rule_add(sw, e->vtcam_id, e->key.prio,
 					  e->key.match.key, e->key.match.mask,
@@ -991,6 +997,9 @@ __prestera_acl_rule_entry_act_construct(struct prestera_switch *sw,
 		if (err && arg->count.fail_on_err)
 			goto err_out;
 	}
+	/* remark */
+	e->remark.valid = arg->remark.valid;
+	e->remark.i = arg->remark.i;
 
 	return 0;
 
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_acl.h b/drivers/net/ethernet/marvell/prestera/prestera_acl.h
index 40cbf8756291..c8f4ceb38ad0 100644
--- a/drivers/net/ethernet/marvell/prestera/prestera_acl.h
+++ b/drivers/net/ethernet/marvell/prestera/prestera_acl.h
@@ -115,6 +115,10 @@ struct prestera_acl_rule_entry {
 			u32 id;
 			struct prestera_counter_block *block;
 		} counter;
+		struct {
+			u8 valid:1;
+			struct prestera_acl_action_remark i;
+		} remark;
 	};
 };
 
@@ -152,6 +156,10 @@ struct prestera_acl_rule_entry_arg {
 			u8 valid:1, fail_on_err:1;
 			u32 client;
 		} count;
+		struct {
+			u8 valid:1;
+			struct prestera_acl_action_remark i;
+		} remark;
 	};
 };
 
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_dcb.c b/drivers/net/ethernet/marvell/prestera/prestera_dcb.c
index e456ea8b8e62..76324faa4a58 100644
--- a/drivers/net/ethernet/marvell/prestera/prestera_dcb.c
+++ b/drivers/net/ethernet/marvell/prestera/prestera_dcb.c
@@ -7,6 +7,144 @@
 #include "prestera.h"
 #include "prestera_hw.h"
 #include "prestera_dcb.h"
+#include "prestera_acl.h"
+
+#define PRESTERA_ACL_QOS_REMARK_PRIO (0)
+#define PRESTERA_QOS_SP_TO_PROFILE_INDEX(__sp) ((__sp) | 0b1000)
+
+struct prestera_qos {
+	struct prestera_acl_rule_entry *rule[IEEE_8021QAZ_MAX_TCS];
+	bool bind;
+	u32 trust_mode;
+	u32 vtcam_id;
+	u8 uid;
+};
+
+struct prestera_acl_prio_dscp_map {
+	u32 dscp[IEEE_8021QAZ_MAX_TCS];
+};
+
+static int prestera_qos_remark_port_bind(struct prestera_port *port)
+{
+	struct prestera_acl *acl = port->sw->acl;
+	struct prestera_acl_iface iface;
+	struct prestera_acl_match match;
+	u32 vtcam_id;
+	int err = 0;
+	u32 uid = 0;
+	u32 pcl_id;
+
+	err = idr_alloc_u32(&acl->uid, NULL, &uid, U8_MAX, GFP_KERNEL);
+	if (err)
+		goto err_uid;
+
+	memset(&match, 0, sizeof(match));
+	rule_match_set_u16(match.mask, PCL_ID, PRESTERA_ACL_KEYMASK_PCL_ID);
+	rule_match_set_u8(match.mask, QOS_PROFILE, 0xff);
+
+	err = prestera_acl_vtcam_id_get(acl, 0, PRESTERA_HW_VTCAM_DIR_EGRESS,
+					match.mask, &vtcam_id);
+	if (err)
+		goto err_vtcam;
+
+	pcl_id = PRESTERA_ACL_PCL_ID_MAKE((u8)uid, 0);
+	iface.type = PRESTERA_ACL_IFACE_TYPE_PORT;
+	iface.port = port;
+
+	err = prestera_hw_vtcam_iface_bind(port->sw, &iface,
+					   vtcam_id, pcl_id);
+	if (err)
+		goto err_bind;
+
+	port->qos->uid = uid;
+	port->qos->vtcam_id = vtcam_id;
+	port->qos->bind = true;
+
+	return 0;
+err_bind:
+	prestera_acl_vtcam_id_put(acl, vtcam_id);
+err_vtcam:
+	idr_remove(&acl->uid, uid);
+err_uid:
+	return err;
+}
+
+static void prestera_qos_remark_port_unbind(struct prestera_port *port)
+{
+	struct prestera_acl *acl = port->sw->acl;
+	struct prestera_acl_iface iface = {
+		.type = PRESTERA_ACL_IFACE_TYPE_PORT,
+		.port = port
+	};
+
+	if (!port->qos->bind)
+		return;
+
+	WARN_ON(prestera_hw_vtcam_iface_unbind(port->sw, &iface,
+					       port->qos->vtcam_id));
+	WARN_ON(prestera_acl_vtcam_id_put(acl, port->qos->vtcam_id));
+	idr_remove(&acl->uid, port->qos->uid);
+
+	port->qos->bind = false;
+}
+
+static void prestera_qos_remark_rules_del(struct prestera_port *port)
+{
+	int i;
+
+	for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {
+		if (!port->qos->rule[i])
+			continue;
+
+		prestera_acl_rule_entry_destroy(port->sw->acl,
+						port->qos->rule[i]);
+		port->qos->rule[i] = NULL;
+	}
+}
+
+static int prestera_qos_remark_rules_add(struct prestera_port *port,
+					 struct prestera_acl_prio_dscp_map *map)
+{
+	struct prestera_acl_rule_entry_key re_key;
+	struct prestera_acl_rule_entry_arg re_arg;
+	struct prestera_acl_rule_entry *re;
+	u32 pcl_id;
+	int err;
+	int i;
+
+	memset(&re_key, 0, sizeof(re_key));
+	memset(&re_arg, 0, sizeof(re_arg));
+
+	pcl_id = PRESTERA_ACL_PCL_ID_MAKE(port->qos->uid, 0);
+	re_key.prio = PRESTERA_ACL_QOS_REMARK_PRIO;
+	re_arg.remark.valid = 1;
+	re_arg.vtcam_id = port->qos->vtcam_id;
+
+	rule_match_set_u16(re_key.match.key, PCL_ID, pcl_id);
+	rule_match_set_u16(re_key.match.mask, PCL_ID,
+			   PRESTERA_ACL_KEYMASK_PCL_ID);
+	rule_match_set_u8(re_key.match.mask, QOS_PROFILE, 0xff);
+
+	for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {
+		rule_match_set_u8(re_key.match.key, QOS_PROFILE,
+				  PRESTERA_QOS_SP_TO_PROFILE_INDEX(i));
+		re_arg.remark.i.dscp = map->dscp[i];
+
+		re = prestera_acl_rule_entry_create(port->sw->acl, &re_key,
+						    &re_arg);
+		err = !re ? -EINVAL : 0;
+		if (err)
+			goto err_rule_add;
+
+		port->qos->rule[i] = re;
+	}
+
+	return 0;
+
+err_rule_add:
+	prestera_qos_remark_rules_del(port);
+	return err;
+}
 
 static int prestera_dcb_app_validate(struct net_device *dev,
 				     struct dcb_app *app)
@@ -82,44 +220,76 @@ static void prestera_dcb_port_dscp_prio_map(struct prestera_port *port,
 	}
 }
 
-static bool prestera_dcb_port_have_dscp(struct prestera_port *port)
+static bool prestera_dcb_port_prio_dscp_map(struct prestera_port *port,
+					    struct dcb_ieee_app_prio_map *map)
 {
-	struct dcb_ieee_app_prio_map map;
+	bool have_dscp = false;
 	int i;
 
-	dcb_ieee_getapp_prio_dscp_mask_map(port->net_dev, &map);
-	for (i = 0; i < ARRAY_SIZE(map.map); ++i)
-		if (map.map[i])
-			return true;
+	dcb_ieee_getapp_prio_dscp_mask_map(port->net_dev, map);
+	for (i = 0; i < ARRAY_SIZE(map->map); ++i) {
+		if (map->map[i]) {
+			map->map[i] = fls64(map->map[i]) - 1;
+			have_dscp = true;
+		}
+	}
 
-	return false;
+	return have_dscp;
+}
+
+static int prestera_port_trust_mode_set(struct prestera_port *port, u8 mode)
+{
+	int err;
+
+	err = prestera_hw_port_qos_trust_mode_set(port, mode);
+	if (err)
+		return err;
+
+	if (mode == PRESTERA_HW_QOS_TRUST_MODE_L3) {
+		err = prestera_qos_remark_port_bind(port);
+		if (err)
+			goto err_trust_mode;
+	} else {
+		prestera_qos_remark_rules_del(port);
+		prestera_qos_remark_port_unbind(port);
+	}
+
+	port->qos->trust_mode = mode;
+	return 0;
+
+err_trust_mode:
+	prestera_hw_port_qos_trust_mode_set(port, port->qos->trust_mode);
+	return err;
 }
 
 static int prestera_dcb_port_app_update(struct prestera_port *port,
 					struct dcb_app *app)
 {
-	struct dcb_ieee_app_dscp_map map;
+	struct prestera_acl_prio_dscp_map remark_map;
+	struct dcb_ieee_app_dscp_map dscp_map;
+	struct dcb_ieee_app_prio_map prio_map;
 	u8 default_prio;
+	bool have_dscp;
 	int err = 0;
 	u8 mode;
+	int i;
 
-	mode = prestera_dcb_port_have_dscp(port) ?
-		PRESTERA_HW_QOS_TRUST_MODE_L3 :
-		PRESTERA_HW_QOS_TRUST_MODE_L2;
+	have_dscp = prestera_dcb_port_prio_dscp_map(port, &prio_map);
 
-	if (port->qos_trust_mode != mode) {
-		err = prestera_hw_port_qos_trust_mode_set(port, mode);
+	mode = have_dscp ? PRESTERA_HW_QOS_TRUST_MODE_L3 :
+			   PRESTERA_HW_QOS_TRUST_MODE_L2;
+
+	if (port->qos->trust_mode != mode) {
+		err = prestera_port_trust_mode_set(port, mode);
 		if (err) {
 			netdev_err(port->net_dev,
 				   "Failed to configure trust mode\n");
 			return err;
 		}
-
-		port->qos_trust_mode = mode;
 	}
 
 	default_prio = prestera_dcb_port_default_prio(port);
-	prestera_dcb_port_dscp_prio_map(port, default_prio, &map);
+	prestera_dcb_port_dscp_prio_map(port, default_prio, &dscp_map);
 
 	err = prestera_hw_port_qos_default_prio_set(port, default_prio);
 	if (err) {
@@ -131,9 +301,21 @@ static int prestera_dcb_port_app_update(struct prestera_port *port,
 	if (mode != PRESTERA_HW_QOS_TRUST_MODE_L3)
 		return 0;
 
-	err = prestera_hw_port_qos_mapping_update(port, &map);
-	if (err)
+	err = prestera_hw_port_qos_mapping_update(port, &dscp_map);
+	if (err) {
 		netdev_err(port->net_dev, "Failed to configure priority\n");
+		return err;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(remark_map.dscp); i++)
+		remark_map.dscp[i] = (u32)prio_map.map[i];
+
+	prestera_qos_remark_rules_del(port);
+	err = prestera_qos_remark_rules_add(port, &remark_map);
+	if (err) {
+		netdev_err(port->net_dev, "Failed to create remarking rules\n");
+		return err;
+	}
 
 	return err;
 }
@@ -150,8 +332,7 @@ static int prestera_dcb_port_app_flush(struct prestera_port *port,
 		return err;
 	}
 
-	err = prestera_hw_port_qos_trust_mode_set(port,
-						  PRESTERA_HW_QOS_TRUST_MODE_L2);
+	err = prestera_port_trust_mode_set(port, PRESTERA_HW_QOS_TRUST_MODE_L2);
 	if (err) {
 		netdev_err(port->net_dev,
 			   "Failed to reset trust mode\n");
@@ -206,11 +387,21 @@ static const struct dcbnl_rtnl_ops prestera_dcbnl_ops = {
 
 int prestera_port_dcb_init(struct prestera_port *port)
 {
+	port->qos = kzalloc(sizeof(*port->qos), GFP_KERNEL);
+	if (!port->qos)
+		return -ENOMEM;
+
 	port->net_dev->dcbnl_ops = &prestera_dcbnl_ops;
-	port->qos_trust_mode = PRESTERA_HW_QOS_TRUST_MODE_L2;
+	port->qos->trust_mode = PRESTERA_HW_QOS_TRUST_MODE_L2;
 
 	return 0;
 }
 
 void prestera_port_dcb_fini(struct prestera_port *port)
-{}
+{
+	prestera_qos_remark_rules_del(port);
+	prestera_qos_remark_port_unbind(port);
+	kfree(port->qos);
+
+	port->net_dev->dcbnl_ops = NULL;
+}
diff --git a/drivers/net/ethernet/marvell/prestera/prestera_hw.c b/drivers/net/ethernet/marvell/prestera/prestera_hw.c
index fac76765aa55..f476e3ed736c 100644
--- a/drivers/net/ethernet/marvell/prestera/prestera_hw.c
+++ b/drivers/net/ethernet/marvell/prestera/prestera_hw.c
@@ -498,6 +498,9 @@ struct prestera_msg_acl_action {
 		struct {
 			__le32 id;
 		} count;
+		struct {
+			u32 dscp;
+		} remark;
 	};
 };
 
@@ -842,9 +845,9 @@ static void prestera_hw_build_tests(void)
 	BUILD_BUG_ON(sizeof(struct prestera_msg_rxtx_req) != 8);
 	BUILD_BUG_ON(sizeof(struct prestera_msg_lag_req) != 16);
 	BUILD_BUG_ON(sizeof(struct prestera_msg_cpu_code_counter_req) != 8);
-	BUILD_BUG_ON(sizeof(struct prestera_msg_vtcam_create_req) != 84);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_vtcam_create_req) != 88);
 	BUILD_BUG_ON(sizeof(struct prestera_msg_vtcam_destroy_req) != 8);
-	BUILD_BUG_ON(sizeof(struct prestera_msg_vtcam_rule_add_req) != 168);
+	BUILD_BUG_ON(sizeof(struct prestera_msg_vtcam_rule_add_req) != 176);
 	BUILD_BUG_ON(sizeof(struct prestera_msg_vtcam_rule_del_req) != 12);
 	BUILD_BUG_ON(sizeof(struct prestera_msg_vtcam_bind_req) != 20);
 	BUILD_BUG_ON(sizeof(struct prestera_msg_counter_req) != 16);
@@ -2317,6 +2320,9 @@ static int acl_rule_add_put_action(struct prestera_msg_acl_action *action,
 	case PRESTERA_ACL_RULE_ACTION_COUNT:
 		action->count.id = __cpu_to_le32(info->count.id);
 		break;
+	case PRESTERA_ACL_RULE_ACTION_REMARK:
+		action->remark.dscp = info->remark.dscp;
+		break;
 	default:
 		return -EINVAL;
 	}
-- 
2.17.1

